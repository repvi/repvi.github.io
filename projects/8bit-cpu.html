<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="8-Bit CPU - Custom Verilog Processor with Python Assembler by Alejandro Ramirez">
    <title>8-Bit CPU | Alejandro Ramirez</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../responsive.css">
    <style>
        .project-header {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
            padding: 8rem 2rem 4rem;
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
        }
        .project-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }
        .section-block {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            padding: 2.5rem;
            border-radius: 16px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            margin-bottom: 2.5rem;
        }
        .section-block h2 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
        }
        .feature-list {
            list-style: none;
            padding: 0;
        }
        .feature-list li {
            padding: 1rem;
            margin-bottom: 0.75rem;
            background: rgba(0, 212, 255, 0.05);
            border-left: 3px solid var(--primary-color);
            border-radius: 4px;
        }
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem 1.5rem;
            background: var(--gradient-1);
            color: var(--dark-bg);
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 212, 255, 0.4);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        .metric-item {
            text-align: center;
            padding: 1.5rem;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        .metric-item .value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        .metric-item .label {
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
        .isa-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
        }
        .isa-table th {
            background: rgba(0, 212, 255, 0.15);
            color: var(--primary-color);
            padding: 0.85rem 1rem;
            text-align: left;
            font-size: 0.9rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
        }
        .isa-table td {
            padding: 0.85rem 1rem;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
            color: var(--text-color);
            font-size: 0.95rem;
        }
        .isa-table tr:last-child td {
            border-bottom: none;
        }
        .isa-table tr:hover td {
            background: rgba(0, 212, 255, 0.05);
        }
        .opcode-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            background: rgba(0, 212, 255, 0.15);
            color: var(--primary-color);
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
            letter-spacing: 0.08em;
        }
        .mem-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1.25rem;
            margin-top: 1.5rem;
        }
        .mem-region {
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.25);
        }
        .mem-region.rom  { border-color: #00d4ff55; background: rgba(0, 212, 255, 0.06); }
        .mem-region.ram  { border-color: #7b61ff55; background: rgba(123, 97, 255, 0.06); }
        .mem-region.io   { border-color: #ff6b6b55; background: rgba(255, 107, 107, 0.06); }
        .mem-region h3 {
            margin: 0 0 0.5rem;
            font-size: 1.1rem;
        }
        .mem-region.rom h3 { color: var(--primary-color); }
        .mem-region.ram h3 { color: #a78bfa; }
        .mem-region.io  h3 { color: #f87171; }
        .mem-region p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .pipeline-row {
            display: flex;
            align-items: center;
            gap: 0;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }
        .pipeline-stage {
            flex: 1;
            min-width: 90px;
            text-align: center;
            padding: 1rem 0.5rem;
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.2);
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--primary-color);
        }
        .pipeline-stage:first-child { border-radius: 8px 0 0 8px; }
        .pipeline-stage:last-child  { border-radius: 0 8px 8px 0; }
        .pipeline-arrow {
            color: var(--primary-color);
            font-size: 1.2rem;
            padding: 0 0.1rem;
        }
    </style>
</head>
<body>
    <div class="project-header">
        <h1 class="my-heading">
            <i class="fas fa-microchip"></i> 8-Bit CPU
        </h1>
        <p class="lead-para" style="max-width: 800px; margin: 1.5rem auto 0;">
            Custom 8-bit processor designed in Verilog with a full ISA, Python-based assembler, ROM/RAM/IO memory map, and verified on real FPGA hardware and Vivado simulation.
        </p>
        <p style="color: var(--primary-color); margin-top: 1rem; font-weight: 600;">
            Hardware Verified &mdash; FPGA + Vivado Simulation
        </p>
    </div>

    <div class="project-content">
        <a href="../index.html#projects" class="back-button">
            <i class="fas fa-arrow-left"></i> Back to Portfolio
        </a>

        <!-- Overview -->
        <div class="section-block">
            <h2><i class="fas fa-rocket"></i> Project Overview</h2>
            <p class="lead-para">
                <strong>&#9889; A fully custom 8-bit CPU — designed from the ground up in Verilog.</strong> This processor implements a complete instruction set architecture with 4 general-purpose registers, a structured memory map (ROM, RAM, I/O), and a synchronous address/data bus. Programs are written in a custom assembly language and translated to machine code using a <strong>Python assembler</strong> that runs directly on the host machine. Every design decision was validated both in <strong>Vivado behavioral simulation</strong> and on <strong>real FPGA hardware</strong>.
            </p>
        </div>

        <!-- Why I Built This -->
        <div class="section-block">
            <h2><i class="fas fa-lightbulb"></i> Why I Built This</h2>
            <p class="lead-para">
                Most developers use CPUs as black boxes. I wanted to understand what actually happens at the register-transfer level — how an instruction moves from ROM, through the decoder, into the ALU, and back to a register. The only honest way to learn that is to <strong>build one yourself</strong>.
            </p>
            <p class="lead-para">
                The goal was never to compete with commercial architectures. It was to build something <strong>complete and correct</strong>: a processor that could fetch an instruction, decode it, execute arithmetic and logic operations, and read/write memory — all with well-defined timing that I could probe in a waveform viewer. Every module had to pass simulation before it touched real hardware.
            </p>
            <p class="lead-para">
                Designing the <strong>memory map decoder</strong> was especially revealing. The moment you need to choose between ROM, RAM, and I/O based on an address, you realize exactly why modern architectures dedicate silicon to bus arbitration. Implementing that logic in Verilog made the trade-offs concrete in a way no textbook could.
            </p>
            <p class="lead-para">
                Writing the <strong>Python assembler</strong> closed the loop. Watching hand-written assembly produce a binary that the CPU then executed correctly end-to-end — from text file to waveform — was the payoff for every late debugging session.
            </p>
        </div>

        <!-- Key Metrics -->
        <div class="section-block">
            <h2><i class="fas fa-chart-line"></i> Architecture at a Glance</h2>
            <div class="metrics-grid">
                <div class="metric-item">
                    <div class="value">8-bit</div>
                    <div class="label">Data Width</div>
                </div>
                <div class="metric-item">
                    <div class="value">4</div>
                    <div class="label">General Registers</div>
                </div>
                <div class="metric-item">
                    <div class="value">14+</div>
                    <div class="label">Instructions</div>
                </div>
                <div class="metric-item">
                    <div class="value">3</div>
                    <div class="label">Memory Regions</div>
                </div>
            </div>
        </div>

        <!-- ISA -->
        <div class="section-block">
            <h2><i class="fas fa-list-ol"></i> Instruction Set Architecture</h2>
            <p class="lead-para">
                The ISA is designed to cover the fundamental operations needed for a useful general-purpose processor while keeping the decode logic straightforward. Immediate variants allow literal values to be embedded directly in the instruction word, eliminating the need for a separate load-immediate sequence.
            </p>
            <table class="isa-table">
                <thead>
                    <tr>
                        <th>Mnemonic</th>
                        <th>Variant</th>
                        <th>Operation</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="opcode-badge">ADD</span></td>
                        <td>Register / Immediate</td>
                        <td>Rd = Rs + Rn / Imm</td>
                        <td>Add two registers or a register and an immediate value</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">SUB</span></td>
                        <td>Register / Immediate</td>
                        <td>Rd = Rs &minus; Rn / Imm</td>
                        <td>Subtract register or immediate from a source register</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">MOV</span></td>
                        <td>Register / Immediate</td>
                        <td>Rd = Rs / Imm</td>
                        <td>Copy a register value or load an 8-bit immediate into a destination register</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">OR</span></td>
                        <td>Register / Immediate</td>
                        <td>Rd = Rs | Rn / Imm</td>
                        <td>Bitwise OR — register-to-register or register-immediate</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">AND</span></td>
                        <td>Register / Immediate</td>
                        <td>Rd = Rs &amp; Rn / Imm</td>
                        <td>Bitwise AND — register-to-register or register-immediate</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">LDA</span></td>
                        <td>Memory Read</td>
                        <td>Rd = MEM[addr]</td>
                        <td>Load a value from a RAM address into a register</td>
                    </tr>
                    <tr>
                        <td><span class="opcode-badge">STA</span></td>
                        <td>Memory Write</td>
                        <td>MEM[addr] = Rs</td>
                        <td>Store a register value to a RAM address</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Memory Map -->
        <div class="section-block">
            <h2><i class="fas fa-map"></i> Memory Map &amp; Address Decoding</h2>
            <p class="lead-para">
                A dedicated <strong>memory map decoder</strong> sits between the CPU core and the three memory regions. It inspects the upper bits of the address bus on every bus cycle and asserts the appropriate chip-enable signal, routing the transaction to the correct module. This keeps the CPU core agnostic to the physical memory layout — swapping region sizes only requires changing the decoder.
            </p>
            <div class="mem-map">
                <div class="mem-region rom">
                    <h3><i class="fas fa-scroll"></i> ROM &mdash; Program Memory</h3>
                    <p>Stores the compiled instruction binary produced by the Python assembler. Read-only at runtime. The program counter addresses into this region during the fetch stage. Initialized at synthesis time from the assembler output.</p>
                </div>
                <div class="mem-region ram">
                    <h3><i class="fas fa-database"></i> RAM &mdash; Data Memory</h3>
                    <p>General-purpose read/write storage used by <span style="font-family:monospace;color:#a78bfa;">LDA</span> and <span style="font-family:monospace;color:#a78bfa;">STA</span> instructions. Accessible during execution for storing intermediate values, variables, and stack-like structures.</p>
                </div>
                <div class="mem-region io">
                    <h3><i class="fas fa-plug"></i> I/O &mdash; Peripheral Registers</h3>
                    <p>Memory-mapped I/O region enabling the CPU to communicate with peripherals using standard store/load instructions. Writing to an I/O address drives on-board outputs; reading returns peripheral state without special instructions.</p>
                </div>
            </div>
        </div>

        <!-- Execution Pipeline -->
        <div class="section-block">
            <h2><i class="fas fa-stream"></i> Execution Pipeline</h2>
            <p class="lead-para">
                The CPU follows a classic <strong>fetch &rarr; decode &rarr; execute</strong> cycle, with the control unit sequencing each stage on the clock edge. Each stage is a distinct Verilog always block, making the data flow explicit and easy to trace in simulation waveforms.
            </p>
            <div class="pipeline-row">
                <div class="pipeline-stage"><i class="fas fa-download"></i><br>Fetch<br><small style="color:var(--text-secondary);font-weight:400;">PC &rarr; ROM</small></div>
                <div class="pipeline-stage"><i class="fas fa-search"></i><br>Decode<br><small style="color:var(--text-secondary);font-weight:400;">Opcode split</small></div>
                <div class="pipeline-stage"><i class="fas fa-calculator"></i><br>Execute<br><small style="color:var(--text-secondary);font-weight:400;">ALU / MEM</small></div>
                <div class="pipeline-stage"><i class="fas fa-save"></i><br>Write-Back<br><small style="color:var(--text-secondary);font-weight:400;">Result &rarr; Reg</small></div>
                <div class="pipeline-stage"><i class="fas fa-step-forward"></i><br>PC Update<br><small style="color:var(--text-secondary);font-weight:400;">PC = PC + 1</small></div>
            </div>
        </div>

        <!-- Assembler -->
        <div class="section-block">
            <h2><i class="fas fa-terminal"></i> Python Assembler</h2>
            <p class="lead-para">
                Programs are written in a human-readable assembly language and translated to binary machine code by a <strong>Python assembler script</strong>. The assembler parses each line, resolves mnemonics and operands to their encoded bit patterns, and outputs a binary file that is loaded into the CPU's ROM at synthesis or simulation time.
            </p>
            <ul class="feature-list">
                <li><strong>Mnemonic Resolution:</strong> Maps each instruction keyword (ADD, SUB, MOV, OR, AND, LDA, STA) and its variant (register vs. immediate) to the correct opcode field</li>
                <li><strong>Operand Encoding:</strong> Encodes register numbers (R1–R4) and 8-bit immediate values into the correct bit positions of the instruction word</li>
                <li><strong>Memory Address Handling:</strong> Resolves LDA/STA address operands and validates they fall within the defined RAM region of the memory map</li>
                <li><strong>Binary Output:</strong> Produces a flat binary or hex file compatible with Vivado's <code>$readmemb</code> / <code>$readmemh</code> ROM initialization directives</li>
                <li><strong>Error Reporting:</strong> Catches undefined mnemonics, out-of-range immediates, and invalid register references with descriptive error messages</li>
            </ul>
        </div>

        <!-- Technical Challenges -->
        <div class="section-block">
            <h2><i class="fas fa-exclamation-triangle"></i> Technical Challenges Solved</h2>
            <ul class="feature-list">
                <li><strong>Memory Map Decoding:</strong> Designed a combinational address decoder that cleanly partitions the address space into ROM, RAM, and I/O regions without adding extra clock cycles to bus transactions</li>
                <li><strong>Immediate vs. Register Variants:</strong> Unified the instruction encoding so the ALU receives the same interface regardless of whether the second operand comes from a register file or an inline immediate field — simplifying control logic significantly</li>
                <li><strong>Simulation-to-Hardware Parity:</strong> Ensured timing constraints and reset behavior were consistent between Vivado behavioral simulation and synthesis, avoiding surprises during FPGA bring-up</li>
                <li><strong>Assembler Correctness:</strong> Validated the assembler output against hand-computed machine code and cross-checked execution results in simulation before committing changes to the hardware bitstream</li>
                <li><strong>Bus Timing:</strong> Synchronized address, data, and control signals correctly on the clock edge so that read and write transactions completed in a single cycle without bus contention</li>
                <li><strong>Register File Design:</strong> Implemented a 4-register file with simultaneous read and write ports, supporting instruction formats that read two source registers and write one destination in a single cycle</li>
            </ul>
        </div>

        <!-- Technologies -->
        <div class="section-block">
            <h2><i class="fas fa-tools"></i> Technologies Used</h2>
            <div class="project-tags" style="display: flex; flex-wrap: wrap; gap: 0.75rem;">
                <span class="tag">Verilog</span>
                <span class="tag">FPGA</span>
                <span class="tag">Vivado</span>
                <span class="tag">Python</span>
                <span class="tag">RTL Design</span>
                <span class="tag">Custom ISA</span>
                <span class="tag">ALU</span>
                <span class="tag">Memory Map</span>
                <span class="tag">Assembly Language</span>
                <span class="tag">Behavioral Simulation</span>
            </div>
        </div>

        <!-- Links -->
        <div class="section-block">
            <h2><i class="fas fa-code-branch"></i> Open Source &amp; Contact</h2>
            <p class="lead-para">
                The full Verilog source, Python assembler, and test programs are publicly available on GitHub. Feel free to explore the code, open issues, or reach out to discuss the design.
            </p>
            <div style="display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap;">
                <a href="https://github.com/repvi/8-Bit-CPU" target="_blank" class="btn common-btn">
                    <i class="fab fa-github"></i> View on GitHub
                </a>
                <a href="../index.html#contact" class="btn ghost-btn">
                    <i class="fas fa-comments"></i> Discuss Design
                </a>
                <a href="../index.html#contact" class="btn ghost-btn">
                    <i class="fas fa-video"></i> Request Demo
                </a>
            </div>
        </div>

        <a href="../index.html#projects" class="back-button" style="margin-top: 2rem;">
            <i class="fas fa-arrow-left"></i> Back to Portfolio
        </a>
    </div>

    <script src="../script.js"></script>
</body>
</html>
